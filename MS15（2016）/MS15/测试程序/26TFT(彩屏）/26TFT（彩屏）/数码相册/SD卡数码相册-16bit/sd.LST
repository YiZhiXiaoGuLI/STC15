C51 COMPILER V9.01   SD                                                                    07/13/2013 19:14:00 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE SD
OBJECT MODULE PLACED IN sd.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE sd.c LARGE DEBUG OBJECTEXTEND

line level    source

   1          #include "sd.h"
   2          
   3          
   4          /*******************************************************
   5          
   6                  
   7          ********************************************************/
   8          
   9          //±äÁ¿¶¨Òå
  10          //--------------------------------------------------------------
  11          bit is_init;        //ÔÚ³õÊ¼»¯µÄÊ±ºòÉèÖÃ´Ë±äÁ¿Îª1,Í¬²½Êý¾Ý´«Êä£¨SPI£©»á·ÅÂý
  12          //---------------------------------------------------------------
  13          
  14          /**********************************************************
  15          
  16           usÑÓÊ±×Ó³ÌÐò  (4.34us)
  17          
  18          **********************************************************/
  19          void delayNOP()
  20          {
  21   1              uchar i=3*12;
  22   1              while(i--);
  23   1      }
  24          
  25          //#define STC_SPI
  26          
  27          /******************************************************************
  28           - ¹¦ÄÜÃèÊö£ºIOÄ£ÄâSPI£¬·¢ËÍÒ»¸ö×Ö½Ú
  29           - Á¥ÊôÄ£¿é£ºSD¿¨Ä£¿é
  30           - º¯ÊýÊôÐÔ£ºÄÚ²¿
  31           - ²ÎÊýËµÃ÷£ºxÊÇÒª·¢ËÍµÄ×Ö½Ú
  32           - ·µ»ØËµÃ÷£ºÎÞ·µ»Ø
  33           - ×¢£º      ÆäÖÐis_initÎª1Ê±£¬Ð´µÄËÙ¶È·ÅÂý£¬³õÊ¼»¯SD¿¨SPIËÙ¶È²»ÄÜÌ«¸ß
  34           ******************************************************************/
  35          
  36          void SD_spi_write(uchar x) 
  37          {
  38   1         uchar i;
  39   1      
  40   1              for (i=0;i<8;i++)
  41   1              { 
  42   2                      if (x&0x80)
  43   2                              SD_SI=1;      //Send bit by bit(MSB First)
  44   2                      else 
  45   2                              SD_SI=0;
  46   2      
  47   2              SD_SCL=0;         //Clock low
  48   2           if(is_init)
  49   2                delayNOP();
  50   2           SD_SCL=1;        //Clock High
  51   2           if(is_init)
  52   2                delayNOP();
  53   2      
  54   2                      x <<=1;
  55   2              }
C51 COMPILER V9.01   SD                                                                    07/13/2013 19:14:00 PAGE 2   

  56   1      
  57   1      }
  58          
  59          /******************************************************************
  60           - ¹¦ÄÜÃèÊö£ºIOÄ£ÄâSPI£¬¶ÁÈ¡Ò»¸ö×Ö½Ú
  61           - Á¥ÊôÄ£¿é£ºSD¿¨Ä£¿é
  62           - º¯ÊýÊôÐÔ£ºÄÚ²¿
  63           - ²ÎÊýËµÃ÷£ºÎÞ
  64           - ·µ»ØËµÃ÷£º·µ»Ø¶Áµ½µÄ×Ö½Ú
  65           ******************************************************************/
  66          
  67          uchar SD_spi_read() //SPI¶ÁÒ»¸ö×Ö½Ú
  68          { 
  69   1      
  70   1         uchar temp=0;
  71   1         uchar i;
  72   1         SD_SO=1;
  73   1      
  74   1              for (i=0;i<8;i++)    //MSB First
  75   1              {
  76   2                      if(is_init)
  77   2                      {
  78   3                              SD_SCL=0;         //Clock Low
  79   3                              delayNOP();   
  80   3                      SD_SCL=1;         //Clock High 
  81   3                              delayNOP();     
  82   3                      }
  83   2                      else
  84   2                      {
  85   3                      SD_SCL=0;         //Clock Low
  86   3                      SD_SCL=1;         //Clock High
  87   3                      } 
  88   2                      SD_SO=1;
  89   2                      temp=(temp<<1)|SD_SO;     //read mmc data out pin 
  90   2              }
  91   1              return (temp);
  92   1      }
  93          
  94          /******************************************************************
  95           - ¹¦ÄÜÃèÊö£ºÏòSD¿¨Ð´ÃüÁî
  96           - Á¥ÊôÄ£¿é£ºSD¿¨Ä£¿é
  97           - º¯ÊýÊôÐÔ£ºÄÚ²¿
  98           - ²ÎÊýËµÃ÷£ºSD¿¨µÄÃüÁîÊÇ6¸ö×Ö½Ú£¬pcmdÊÇÖ¸ÏòÃüÁî×Ö½ÚÐòÁÐµÄÖ¸Õë
  99           - ·µ»ØËµÃ÷£ºÃüÁîÐ´Èëºó£¬SD¿¨µÄ»ØÓ¦Öµ£¬µ÷ÓÃ²»³É¹¦£¬½«·µ»Ø0xff
 100           ******************************************************************/
 101          
 102          uchar SD_Write_Cmd(uchar *pcmd) //ÏòSD¿¨Ð´ÃüÁî£¬pcmdÊÇÃüÁî×Ö½ÚÐòÁÐµÄÊ×µØÖ·
 103          {
 104   1              uchar temp,time=0;
 105   1      
 106   1              SD_CS=1;
 107   1              SD_spi_write(0xff); //Ìá¸ß¼æÈÝÐÔ£¬Èç¹ûÃ»ÓÐÕâÀï£¬ÓÐÐ©SD¿¨¿ÉÄÜ²»Ö§³Ö   
 108   1              SD_CS=0;
 109   1      
 110   1              SD_spi_write(pcmd[0]);
 111   1              SD_spi_write(pcmd[1]);
 112   1              SD_spi_write(pcmd[2]);
 113   1              SD_spi_write(pcmd[3]);
 114   1          SD_spi_write(pcmd[4]);
 115   1              SD_spi_write(pcmd[5]);
 116   1      
 117   1              do{  
C51 COMPILER V9.01   SD                                                                    07/13/2013 19:14:00 PAGE 3   

 118   2                      temp = SD_spi_read();//Ò»Ö±¶Á£¬Ö±µ½¶Áµ½µÄ²»ÊÇ0xff»ò³¬Ê±
 119   2                      time++;
 120   2              }while((temp==0xff)&&(time<TRY_TIME)); 
 121   1      
 122   1              return(temp);
 123   1      }
 124          
 125          /******************************************************************
 126           - ¹¦ÄÜÃèÊö£º¸´Î»SD¿¨£¬ÓÃµ½CMD0£¬Ê¹ÓÃSD¿¨ÇÐ»»µ½SPIÄ£Ê½
 127           - Á¥ÊôÄ£¿é£ºSD¿¨Ä£¿é
 128           - º¯ÊýÊôÐÔ£ºÄÚ²¿
 129           - ²ÎÊýËµÃ÷£ºÎÞ
 130           - ·µ»ØËµÃ÷£ºµ÷ÓÃ³É¹¦£¬·µ»Ø0x00£¬·ñÔò·µ»ØINIT_CMD0_ERROR (sd.hÖÐÓÐ¶¨Òå)
 131           ******************************************************************/
 132          
 133          uchar SD_Reset()//SD¿¨¸´Î»£¬½øÈëSPIÄ£Ê½£¬Ê¹ÓÃCMD0£¨0ºÅÃüÁî£©
 134          {
 135   1              uchar idata time,temp,i;
 136   1              uchar idata pcmd[] = {0x40,0x00,0x00,0x00,0x00,0x95}; 
 137   1              
 138   1         SD_SCL=1;
 139   1         SD_SO =1;
 140   1         SD_CS=1; 
 141   1      
 142   1              is_init=1; //Set the init flag
 143   1      
 144   1              for(i=0;i<0x0f;i++) //³õÊ¼Ê±£¬Ê×ÏÈÒª·¢ËÍ×îÉÙ74¸öÊ±ÖÓÐÅºÅ£¬ÕâÊÇ±ØÐëµÄ£¡£¡£¡
 145   1              {
 146   2                       SD_spi_write(0xff); //120 clk
 147   2              }
 148   1      
 149   1              SD_CS=0;
 150   1              time=0;
 151   1              do
 152   1              { 
 153   2                      temp=SD_Write_Cmd(pcmd);//Ð´ÈëCMD0
 154   2                      time++;
 155   2                      if(time>=TRY_TIME) 
 156   2                      { 
 157   3                              return(INIT_CMD0_ERROR);//CMD0Ð´ÈëÊ§°Ü
 158   3                      }
 159   2              }while(temp!=0x01);
 160   1      
 161   1              SD_CS=1;
 162   1      //      SD_spi_write(0xff); //°´ÕÕSD¿¨µÄ²Ù×÷Ê±ÐòÔÚÕâÀï²¹8¸öÊ±ÖÓ 
 163   1              return 0;//·µ»Ø0,ËµÃ÷¸´Î»²Ù×÷³É¹¦
 164   1      }
 165          
 166          /******************************************************************
 167           - ¹¦ÄÜÃèÊö£º³õÊ¼»¯SD¿¨£¬Ê¹ÓÃCMD1
 168           - Á¥ÊôÄ£¿é£ºSD¿¨Ä£¿é
 169           - º¯ÊýÊôÐÔ£ºÄÚ²¿
 170           - ²ÎÊýËµÃ÷£ºÎÞ
 171           - ·µ»ØËµÃ÷£ºµ÷ÓÃ³É¹¦£¬·µ»Ø0x00£¬·ñÔò·µ»ØINIT_CMD1_ERROR (sd.hÖÐÓÐ¶¨Òå)
 172           ******************************************************************/
 173          
 174          uchar SD_Init() //³õÊ¼»¯£¬Ê¹ÓÃCMD1£¨1ºÅÃüÁî£©
 175          {  
 176   1              uchar time,temp;
 177   1              uchar pcmd[] = {0x41,0x00,0x00,0x00,0x00,0xff};
 178   1      
 179   1              SD_CS=0;
C51 COMPILER V9.01   SD                                                                    07/13/2013 19:14:00 PAGE 4   

 180   1      
 181   1              time=0;
 182   1              do
 183   1              { 
 184   2                      temp=SD_Write_Cmd(pcmd);
 185   2                      time++;
 186   2                      if(time==TRY_TIME) 
 187   2                      { 
 188   3                              return(INIT_CMD1_ERROR);//CMD1Ð´ÈëÊ§°Ü
 189   3                      }
 190   2              }while(temp!=0);
 191   1                       
 192   1              is_init=0; //³õÊ¼»¯Íê±Ï£¬½«is_initÉèÖÃÎª0,ÎªÁËÌá¸ßÒÔºóµÄÊý¾Ý´«ÊäËÙ¶È
 193   1      //      #ifdef STC_SPI
 194   1      //      SPCTL = 0xDC;   //Ö÷»ú£¬ºöÂÔSS,CPU_CLK/4 
 195   1      //      #endif
 196   1         
 197   1              SD_CS=1;  //¹Ø×°SD¿¨µÄÆ¬Ñ¡ 
 198   1      
 199   1              SD_spi_write(0xff); //°´ÕÕSD¿¨µÄ²Ù×÷Ê±ÐòÔÚÕâÀï²¹8¸öÊ±ÖÓ
 200   1      
 201   1              return(0); //·µ»Ø0,ËµÃ÷³õÊ¼»¯²Ù×÷³É¹¦
 202   1      } 
 203          
 204          /****************************************************************************
 205           - ¹¦ÄÜÃèÊö£º½«bufferÖ¸ÏòµÄ512¸ö×Ö½ÚµÄÊý¾ÝÐ´Èëµ½SD¿¨µÄaddrÉÈÇøÖÐ
 206           - Á¥ÊôÄ£¿é£ºSD¿¨Ä£¿é
 207           - º¯ÊýÊôÐÔ£ºÄÚ²¿
 208           - ²ÎÊýËµÃ÷£ºaddr:ÉÈÇøµØÖ·
 209                       buffer:Ö¸ÏòÊý¾Ý»º³åÇøµÄÖ¸Õë
 210           - ·µ»ØËµÃ÷£ºµ÷ÓÃ³É¹¦£¬·µ»Ø0x00£¬·ñÔò·µ»ØWRITE_BLOCK_ERROR (sd.hÖÐÓÐ¶¨Òå)
 211           - ×¢£ºSD¿¨³õÊ¼»¯³É¹¦ºó£¬¶ÁÐ´ÉÈÇøÊ±£¬¾¡Á¿½«SPIËÙ¶ÈÌáÉÏÀ´£¬Ìá¸ßÐ§ÂÊ
 212           ****************************************************************************/
 213          
 214          /*uchar SD_Write_Sector(unsigned long addr,uchar *Buffer)       //ÏòSD¿¨ÖÐµÄÖ¸¶¨µØÖ·µÄÉÈÇøÐ´Èë512¸ö×Ö½Ú£¬Ê¹ÓÃCMD
             -24£¨24ºÅÃüÁî£©
 215          {  
 216                  uchar temp,time;
 217                  uint i;
 218                  char pcmd[] = {0x58,0x00,0x00,0x00,0x00,0xff}; //ÏòSD¿¨ÖÐµ¥¸ö¿é£¨512×Ö½Ú£¬Ò»¸öÉÈÇø£©Ð´ÈëÊý¾Ý£¬ÓÃCMD24
 219          
 220                  addr<<=9; //addr = addr * 512   ½«¿éµØÖ·£¨ÉÈÇøµØÖ·£©×ªÎª×Ö½ÚµØÖ· £ÛÕâÀï¾ÍÏÞÖÆÁËSD¿¨µÄ×î´óÈÝÁ¿Îª4G£Ý
 221                  
 222                  pcmd[1]=((addr&0xff000000)>>24); //½«×Ö½ÚµØÖ·Ð´Èëµ½CMD24×Ö½ÚÐòÁÐÖÐ
 223                  pcmd[2]=((addr&0x00ff0000)>>16);
 224                  pcmd[3]=((addr&0x0000ff00)>>8);
 225          
 226                  SD_CS=0;//´ò¿ªSD¿¨Æ¬Ñ¡
 227          
 228                  time=0;
 229                  do
 230                  {  
 231                          temp=SD_Write_Cmd(pcmd);
 232                          time++;
 233                          if(time==TRY_TIME) 
 234                          { 
 235                                  return(temp); //ÃüÁîÐ´ÈëÊ§°Ü
 236                          }
 237                  }while(temp!=0); 
 238          
 239                  for(i=0;i<100;i++) //ÕâÀïÒª²åÈëÈô¸ÉÊ±ÖÓÐÅºÅ
 240                  {
C51 COMPILER V9.01   SD                                                                    07/13/2013 19:14:00 PAGE 5   

 241                          SD_spi_read();
 242                  }
 243                  
 244                  SD_spi_write(0xfe);//Ð´Èë¿ªÊ¼×Ö½Ú 0xfe£¬ºóÃæ¾ÍÊÇÒªÐ´ÈëµÄ512¸ö×Ö½ÚµÄÊý¾Ý 
 245                  
 246                  for (i=0;i<512;i++) //½«»º³åÇøÖÐÒªÐ´ÈëµÄ512¸ö×Ö½ÚÐ´ÈëSD¿¨
 247                  {
 248                          SD_spi_write(*Buffer++);
 249                  }
 250            
 251                  SD_spi_write(0xFF); 
 252                  SD_spi_write(0xFF); //Á½¸ö×Ö½ÚµÄCRCÐ£ÑéÂë£¬²»ÓÃ¹ØÐÄ
 253              
 254                  temp=SD_spi_read();   //¶ÁÈ¡·µ»ØÖµ
 255                  if((temp & 0x1F)!=0x05) //Èç¹û·µ»ØÖµÊÇ XXX00DELAY_TIME1 ËµÃ÷Êý¾ÝÒÑ¾­±»SD¿¨½ÓÊÜÁË
 256                  {
 257                          SD_CS=1;
 258                          return(WRITE_BLOCK_ERROR); //Ð´¿éÊý¾ÝÊ§°Ü
 259                  }
 260           
 261                  while(SD_spi_read()!=0xff);//µÈµ½SD¿¨²»Ã¦£¨Êý¾Ý±»½ÓÊÜÒÔºó£¬SD¿¨Òª½«ÕâÐ©Êý¾ÝÐ´Èëµ½×ÔÉíµÄFLASHÖÐ£¬ÐèÒªÒ»¸öÊ
             -±¼ä£©
 262                                                           //Ã¦Ê±£¬¶Á»ØÀ´µÄÖµÎª0x00,²»Ã¦Ê±£¬Îª0xff
 263          
 264                  SD_CS=1; //¹Ø±ÕÆ¬Ñ¡
 265          
 266                  SD_spi_write(0xFF);//°´ÕÕSD¿¨µÄ²Ù×÷Ê±ÐòÔÚÕâÀï²¹8¸öÊ±ÖÓ
 267                  return(0);               //·µ»Ø0,ËµÃ÷Ð´ÉÈÇø²Ù×÷³É¹¦
 268          } 
 269          */
 270          /****************************************************************************
 271           - ¹¦ÄÜÃèÊö£º¶ÁÈ¡addrÉÈÇøµÄ512¸ö×Ö½Úµ½bufferÖ¸ÏòµÄÊý¾Ý»º³åÇø
 272           - Á¥ÊôÄ£¿é£ºSD¿¨Ä£¿é
 273           - º¯ÊýÊôÐÔ£ºÄÚ²¿
 274           - ²ÎÊýËµÃ÷£ºaddr:ÉÈÇøµØÖ·
 275                       buffer:Ö¸ÏòÊý¾Ý»º³åÇøµÄÖ¸Õë
 276           - ·µ»ØËµÃ÷£ºµ÷ÓÃ³É¹¦£¬·µ»Ø0x00£¬·ñÔò·µ»ØREAD_BLOCK_ERROR (sd.hÖÐÓÐ¶¨Òå)
 277           - ×¢£ºSD¿¨³õÊ¼»¯³É¹¦ºó£¬¶ÁÐ´ÉÈÇøÊ±£¬¾¡Á¿½«SPIËÙ¶ÈÌáÉÏÀ´£¬Ìá¸ßÐ§ÂÊ
 278           ****************************************************************************/
 279          
 280          uchar SD_Read_Sector(unsigned long addr,uchar *buffer)//´ÓSD¿¨µÄÖ¸¶¨ÉÈÇøÖÐ¶Á³ö512¸ö×Ö½Ú£¬Ê¹ÓÃCMD17£¨17ºÅÃü
             -Áî£©
 281          {
 282   1              uint j;
 283   1              uchar time,temp;
 284   1              uchar pcmd[]={0x51,0x00,0x00,0x00,0x00,0xFF}; //CMD17µÄ×Ö½ÚÐòÁÐ
 285   1         
 286   1              addr<<=9; //sector = sector * 512          ½«¿éµØÖ·£¨ÉÈÇøµØÖ·£©×ªÎª×Ö½ÚµØÖ·
 287   1      
 288   1              pcmd[1]=((addr&0xFF000000)>>24);
 289   1              pcmd[2]=((addr&0x00FF0000)>>16);
 290   1              pcmd[3]=((addr&0x0000FF00)>>8);
 291   1      
 292   1              SD_CS=0;//´ò¿ªÆ¬Ñ¡ 
 293   1      
 294   1              time=0;
 295   1              do
 296   1              {  
 297   2                      temp=SD_Write_Cmd(pcmd); //Ð´ÈëCMD17
 298   2                      time++;
 299   2                      if(time==TRY_TIME) 
 300   2                      {
C51 COMPILER V9.01   SD                                                                    07/13/2013 19:14:00 PAGE 6   

 301   3                              return(READ_BLOCK_ERROR); //¶Á¿éÊ§°Ü
 302   3                      }
 303   2              }while(temp!=0); 
 304   1                              
 305   1              while (SD_spi_read() != 0xfe); //Ò»Ö±¶Á£¬µ±¶Áµ½0xfeÊ±£¬ËµÃ÷ºóÃæµÄÊÇ512×Ö½ÚµÄÊý¾ÝÁË
 306   1      
 307   1              for(j=0;j<512;j++)       //½«Êý¾ÝÐ´Èëµ½Êý¾Ý»º³åÇøÖÐ
 308   1              {       
 309   2                      buffer[j]=SD_spi_read();
 310   2              }
 311   1      
 312   1              SD_spi_read();
 313   1              SD_spi_read();//¶ÁÈ¡Á½¸ö×Ö½ÚµÄCRCÐ£ÑéÂë£¬²»ÓÃ¹ØÐÄËüÃÇ
 314   1              SD_CS=1;  //SD¿¨¹Ø±ÕÆ¬Ñ¡ 
 315   1              SD_spi_write(0xFF);//°´ÕÕSD¿¨µÄ²Ù×÷Ê±ÐòÔÚÕâÀï²¹8¸öÊ±ÖÓ
 316   1              return 0;
 317   1      }
 318          //---------------------------------------------------SD¿¨Çý¶¯--------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    558    ----
   CONSTANT SIZE    =     18    ----
   XDATA SIZE       =   ----      24
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----       9
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
